package com.example.TricycleDetector.Detector

import android.content.Context
import android.graphics.Bitmap
import android.media.MediaMetadataRetriever
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.net.Uri
import android.os.Environment
import android.util.Log
import android.view.Surface
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.atomic.AtomicBoolean

class VideoDetector(
    context: Context,
    modelPath: String,
    labelPath: String?,
    detectorListener: DetectorListener
) : Detector(context, modelPath, labelPath, detectorListener) {

    private var isProcessing = AtomicBoolean(false)
    private var shouldStopProcessing = AtomicBoolean(false)
    private lateinit var mediaMetadataRetriever: MediaMetadataRetriever
    private var totalFrames: Long = 0
    private var currentFrame: Long = 0
    private var fps: Float = 0f

    fun processVideo(context: Context, videoUri: Uri, saveProcessedVideo: Boolean = false) {
        if (isProcessing.get()) {
            Log.w("VideoDetector", "Video processing already in progress")
            return
        }

        isProcessing.set(true)
        shouldStopProcessing.set(false)

        try {
            mediaMetadataRetriever = MediaMetadataRetriever()
            mediaMetadataRetriever.setDataSource(context, videoUri)

            // Get video metadata
            val duration = mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)?.toLong() ?: 0
            fps = mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_CAPTURE_FRAMERATE)?.toFloatOrNull() ?: 30f
            totalFrames = (duration / 1000.0 * fps).toLong()
            currentFrame = 0

            // Create output file if saving is requested
            val outputFile = if (saveProcessedVideo) {
                createOutputVideoFile()
            } else null

            // Process frame by frame
            var timeInMillis: Long = 0
            val frameInterval = (1000 / fps).toLong()

            while (timeInMillis < duration && !shouldStopProcessing.get()) {
                val bitmap = mediaMetadataRetriever.getFrameAtTime(
                    timeInMillis * 1000, // Convert to microseconds
                    MediaMetadataRetriever.OPTION_CLOSEST_SYNC
                )

                bitmap?.let {
                    detect(it)
                    currentFrame++

                    if (saveProcessedVideo && outputFile != null) {
                        // Save processed frame
                        val processedBitmap = (detectorListener as? DetectorListener.WithPreview)?.getLastProcessedFrame()
                        processedBitmap?.let { processed ->
                            saveFrameToFile(processed, outputFile, currentFrame)
                        }
                    }
                }

                timeInMillis += frameInterval
            }

            if (saveProcessedVideo && outputFile != null) {
                combineFramesIntoVideo(outputFile, fps)
            }

        } catch (e: Exception) {
            Log.e("VideoDetector", "Error processing video", e)
        } finally {
            mediaMetadataRetriever.release()
            isProcessing.set(false)
            currentFrame = 0
        }
    }

    fun getProgress(): Float {
        return if (totalFrames > 0) currentFrame.toFloat() / totalFrames else 0f
    }

    fun stopProcessing() {
        shouldStopProcessing.set(true)
    }

    private fun createOutputVideoFile(): File {
        val timeStamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val filename = "PROCESSED_VIDEO_$timeStamp.mp4"
        val storageDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES)
        return File(storageDir, filename)
    }

    private fun saveFrameToFile(bitmap: Bitmap, outputFile: File, frameNumber: Long) {
        val frameFile = File(outputFile.parent, "frame_${frameNumber}.jpg")
        FileOutputStream(frameFile).use { out ->
            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out)
        }
    }

    private fun combineFramesIntoVideo(outputFile: File, fps: Float) {
        // Note: This is a placeholder for the actual video compilation logic
        // You would need to use MediaCodec or a third-party library like FFmpeg
        // to combine the frames into a video file
        Log.i("VideoDetector", "Video processing completed. Output file: ${outputFile.absolutePath}")
    }
}